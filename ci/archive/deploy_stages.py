#!/usr/bin/env python3
"""
Deploy CDK stages based on environment type.

This script reads the stage configuration generated by discover_stages.py
and deploys stages filtered by environment type.
"""

import argparse
import json
import subprocess
import sys
from typing import Dict, List


def load_stage_configs(config_file: str = "stages_config.json") -> List[Dict]:
    """Load stage configurations from JSON file."""
    with open(config_file, "r") as f:
        return json.load(f)


def filter_stages_by_env(configs: List[Dict], env_type: str) -> List[Dict]:
    """
    Filter stage configurations by environment type.

    Args:
        configs: List of stage configurations
        env_type: Environment type to filter ('dev', 'stg', 'prd')

    Returns:
        Filtered list of stage configurations
    """
    return [cfg for cfg in configs if cfg["env_type"] == env_type]


def deploy_stage(stage_config: Dict, dry_run: bool = False) -> bool:
    """
    Deploy a single CDK stage.

    Args:
        stage_config: Stage configuration dictionary
        dry_run: If True, only show what would be deployed

    Returns:
        True if deployment succeeded, False otherwise
    """
    stage_name = stage_config["stage_name"]
    deploy_pattern = stage_config["deploy_pattern"]

    dry_run_prefix = "[DRY RUN] " if dry_run else ""
    emoji = "ğŸ”" if dry_run else "ğŸš€"

    print(f"\n{emoji} {dry_run_prefix}Deploying {stage_name}...")
    print(f"   Pattern: {deploy_pattern}")
    print(f"   Stacks: {', '.join([s.split('/')[-1] for s in stage_config['stacks']])}")

    if dry_run:
        cmd = f"cdk diff {deploy_pattern}"
    else:
        cmd = f"cdk deploy {deploy_pattern} --require-approval never --progress events"

    print(f"   Command: {cmd}")

    result = subprocess.run(cmd, shell=True)

    if result.returncode != 0:
        print(f"âŒ Failed to deploy {stage_name}")
        return False

    print(f"âœ… {stage_name} deployed successfully")
    return True


def main():
    """Main deployment function."""
    parser = argparse.ArgumentParser(description="Deploy CDK stages by environment")
    parser.add_argument(
        "env_type",
        choices=["dev", "stg", "prd", "all"],
        help="Environment type to deploy",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be deployed without actually deploying",
    )
    parser.add_argument(
        "--config",
        default="stages_config.json",
        help="Path to stages configuration file",
    )

    args = parser.parse_args()

    # Load configurations
    print(f"ğŸ“¦ Loading stage configuration from {args.config}...")
    configs = load_stage_configs(args.config)

    # Filter by environment
    if args.env_type == "all":
        stages_to_deploy = configs
    else:
        stages_to_deploy = filter_stages_by_env(configs, args.env_type)

    if not stages_to_deploy:
        print(f"âš ï¸  No stages found for environment: {args.env_type}")
        return 0

    dry_run_prefix = "ğŸ” [DRY RUN] " if args.dry_run else ""
    print(f"\n{dry_run_prefix}Planning to deploy {len(stages_to_deploy)} stage(s):")
    for cfg in stages_to_deploy:
        print(f"  - {cfg['stage_name']} ({cfg['stack_count']} stacks)")

    # Deploy each stage
    failed_stages = []
    for stage_cfg in stages_to_deploy:
        success = deploy_stage(stage_cfg, dry_run=args.dry_run)
        if not success:
            failed_stages.append(stage_cfg["stage_name"])

    # Summary
    print("\n" + "=" * 60)
    if failed_stages:
        print(f"âŒ Deployment failed for {len(failed_stages)} stage(s):")
        for stage in failed_stages:
            print(f"   - {stage}")
        return 1
    else:
        print(f"âœ… All {len(stages_to_deploy)} stage(s) deployed successfully!")
        return 0


if __name__ == "__main__":
    sys.exit(main())
